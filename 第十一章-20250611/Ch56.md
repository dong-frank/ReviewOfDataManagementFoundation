# Ch56 事务调度

## 并发调度的可串行性
数据库管理系统对并发事务不同的调度可能会产生不同的结果

串行调度是正确的

执行结果等价于串行调度的调度也是正确的, 称为可串行化调度


### 可串行化调度
多个事务的并发执行是正确的, 当且仅当其结果与按某一次序串行地执行这些事务时的结果相同

可串行性
- 是并发事务正确调度的准则
- 一个给定的并发调度, 当且仅当它是可串行化的, 才认为是正确调度

### 冲突可串行化
一个比可串行化更严格的条件

商用系统中的调度器采用

冲突操作: 是指不同的事务对同一数据的读写操作和写写操作, 其他操作是不冲突操作

不能交换执行顺序的动作
- 同一事务的两个操作
- 不同事务的冲突操作

一个调度Sc在保证冲突操作的次序不变的情况下, 通过交换两个事务的不冲突操作的次序, 得到另一个调度Sc', 若Sc'串行的, 称调度Sc是冲突可串行化调度

若一个调度是冲突可串行化调度, 则一定是可串行化调度


### 两段锁协议
数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性, 从而保证调度的正确性
- 指所有事务必须分为两个阶段对数据加锁和解锁
- 在对任何数据进行读, 写之前, 事务首先要获得对该数据的封锁
- 在释放一个封锁之后, 事务不再申请和获得任何其他封锁

"两段"锁的含义, 事务分为两个阶段
- 第一阶段是获得封锁, 也称为扩展阶段: 事务可以申请获得任何数据项上的任何类型的锁, 但是不能释放任何锁
- 第二阶段是释放封锁, 也称为收缩阶段: 事务可以释放任何数据项上的任何类型的锁, 但是不能再申请任何锁

事务遵守两段锁协议是可串行化调度的充分条件, 而不是必要条件


两段锁协议与防止死锁的一次封锁法
- 一次封锁法要求每个事务必须一次就将要使用的数据全部加锁, 显然是遵守两段锁协议的
- 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁, 只是不能加锁和释放锁混合, 因此是可能发生死锁的